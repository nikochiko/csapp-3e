{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"chapter3/3.58/","text":"3.58 Problem For a function with prototype long decode2(long x, long y, long z); gcc generates the following assembly code: 1 decode2: 2 subq %rdx, %rsi 3 imulq %rsi, %rdi 4 movq %rsi, %rax 5 salq $63, %rax 6 sarq $63, %rax 7 xorq %rdi, %rax 8 ret Parameters x, y, and z are passed in registers %rdi , %rsi , and %rdx . The code stores the return value in register %rax . Write C code for decode2 that will have an effect equivalent to the assembly code shown. Solution decode2 first computes the value (y - z) * x (let's call it k ), and then converts it to a value whose bit representation contains either all 1s (if k is odd) or all 0s (if k is even). long decode2(long x, long y, long z) { long k = (y - z) * x; k = (k << 63) >> 63; return k ^ x; } Interesting point: In terms of x , what are the two values that this function can return?","title":"3.58"},{"location":"chapter3/3.58/#358","text":"","title":"3.58"},{"location":"chapter3/3.58/#problem","text":"For a function with prototype long decode2(long x, long y, long z); gcc generates the following assembly code: 1 decode2: 2 subq %rdx, %rsi 3 imulq %rsi, %rdi 4 movq %rsi, %rax 5 salq $63, %rax 6 sarq $63, %rax 7 xorq %rdi, %rax 8 ret Parameters x, y, and z are passed in registers %rdi , %rsi , and %rdx . The code stores the return value in register %rax . Write C code for decode2 that will have an effect equivalent to the assembly code shown.","title":"Problem"},{"location":"chapter3/3.58/#solution","text":"decode2 first computes the value (y - z) * x (let's call it k ), and then converts it to a value whose bit representation contains either all 1s (if k is odd) or all 0s (if k is even). long decode2(long x, long y, long z) { long k = (y - z) * x; k = (k << 63) >> 63; return k ^ x; } Interesting point: In terms of x , what are the two values that this function can return?","title":"Solution"},{"location":"chapter3/3.59/","text":"3.59 Problem The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory: 1 typedef __int128 int128_t; 2 3 void store_prod(int128_t *dest, int64_t x, int64_t y) { 4 *dest = x * (int128_t) y; 5 } Gcc generates the following assembly code implementing the computation: 1 store_prod: 2 movq %rdx, %rax 3 cqto 4 movq %rsi, %rcx 5 sarq $63, %rcx 6 imulq %rax, %rcx 7 imulq %rsi, %rdx 8 addq %rdx, %rcx 9 mulq %rsi 10 addq %rcx, %rdx 11 movq %rax, (%rdi) 12 movq %rdx, 8(%rdi) 13 ret This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as x = 264 \u00b7 x h + x l and y = 264 \u00b7 y h + y<sub<l , where x h , x l , y h , and y<sub<l are 64-bit values. Similarly, the 128-bit product can be written as p = 264 \u00b7 ph + pl, where ph and pl are 64-bit values. Show how the code computes the values of ph and pl in terms of x h , x l , y h , and y<sub<l . Solution While reading the assembly code, it's important to remember that the mulq instruction computes a 128-bit result stored in %rdx:%rax% . That is, the high 64 bits in %rdx and the low 64 bits in %rax . \\[ x = 2^{64} \\cdot x_{h} + x_{l},\\ y = 2^{64} \\cdot y_{h} + y_{l} \\] \\[ x \\cdot y = (2^{64} \\cdot x_{h} + x_{l}) \\cdot (2^{64} \\cdot y_{h} + y_{l}) \\] \\[ x \\cdot y = 2^{128} \\cdot x_{h} \\cdot y_{h} + 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] We can ignore the term with \\(2^{128}\\) because it cannot fit in 128 bits, and we'd end up with the remainder. Since \\(p\\) can also be represented similarly in terms of \\(p_{h}\\) and \\(p_{l}\\) , we get \\[ p = 2^{64} \\cdot p_{h} + p_{l} \\] \\[ 2^{64} \\cdot p_{h} + p_{l} = 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] Besides the coefficient of \\(2^{64}\\) on the right hand side, \\(x_{l} \\cdot y_{l}\\) can also add to the value of \\(p_{h}\\) . So, we get: \\[ p_{h} = x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l} + quotient(x_{l} \\cdot y_{l},\\ 2^{64}) \\] And, \\[ p_{l} = (x_{l} \\cdot y_{l}) \\bmod 2^{64} \\] This is reflected in our assembly code, we sign extend both \\(x\\) (to %rdx:%rax with line 2 cqto ) and \\(y\\) (to %rcx:%rsi after line 5 sarq ). We first calculate the value of \\(p_{h}\\) without considering the factor from \\(x_{l} \\cdot y_{l}\\) (after line 8) in %rcx . The mulq instruction then sets %rax and %rdx to the low and high 64-bits of \\(x_{l} \\cdot y_{l}\\) respectively. We then add %rcx to %rdx to get \\(p_{h}\\) by adding the missing factor. %rax is already \\(p_{l}\\) .","title":"3.59"},{"location":"chapter3/3.59/#359","text":"","title":"3.59"},{"location":"chapter3/3.59/#problem","text":"The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory: 1 typedef __int128 int128_t; 2 3 void store_prod(int128_t *dest, int64_t x, int64_t y) { 4 *dest = x * (int128_t) y; 5 } Gcc generates the following assembly code implementing the computation: 1 store_prod: 2 movq %rdx, %rax 3 cqto 4 movq %rsi, %rcx 5 sarq $63, %rcx 6 imulq %rax, %rcx 7 imulq %rsi, %rdx 8 addq %rdx, %rcx 9 mulq %rsi 10 addq %rcx, %rdx 11 movq %rax, (%rdi) 12 movq %rdx, 8(%rdi) 13 ret This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as x = 264 \u00b7 x h + x l and y = 264 \u00b7 y h + y<sub<l , where x h , x l , y h , and y<sub<l are 64-bit values. Similarly, the 128-bit product can be written as p = 264 \u00b7 ph + pl, where ph and pl are 64-bit values. Show how the code computes the values of ph and pl in terms of x h , x l , y h , and y<sub<l .","title":"Problem"},{"location":"chapter3/3.59/#solution","text":"While reading the assembly code, it's important to remember that the mulq instruction computes a 128-bit result stored in %rdx:%rax% . That is, the high 64 bits in %rdx and the low 64 bits in %rax . \\[ x = 2^{64} \\cdot x_{h} + x_{l},\\ y = 2^{64} \\cdot y_{h} + y_{l} \\] \\[ x \\cdot y = (2^{64} \\cdot x_{h} + x_{l}) \\cdot (2^{64} \\cdot y_{h} + y_{l}) \\] \\[ x \\cdot y = 2^{128} \\cdot x_{h} \\cdot y_{h} + 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] We can ignore the term with \\(2^{128}\\) because it cannot fit in 128 bits, and we'd end up with the remainder. Since \\(p\\) can also be represented similarly in terms of \\(p_{h}\\) and \\(p_{l}\\) , we get \\[ p = 2^{64} \\cdot p_{h} + p_{l} \\] \\[ 2^{64} \\cdot p_{h} + p_{l} = 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] Besides the coefficient of \\(2^{64}\\) on the right hand side, \\(x_{l} \\cdot y_{l}\\) can also add to the value of \\(p_{h}\\) . So, we get: \\[ p_{h} = x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l} + quotient(x_{l} \\cdot y_{l},\\ 2^{64}) \\] And, \\[ p_{l} = (x_{l} \\cdot y_{l}) \\bmod 2^{64} \\] This is reflected in our assembly code, we sign extend both \\(x\\) (to %rdx:%rax with line 2 cqto ) and \\(y\\) (to %rcx:%rsi after line 5 sarq ). We first calculate the value of \\(p_{h}\\) without considering the factor from \\(x_{l} \\cdot y_{l}\\) (after line 8) in %rcx . The mulq instruction then sets %rax and %rdx to the low and high 64-bits of \\(x_{l} \\cdot y_{l}\\) respectively. We then add %rcx to %rdx to get \\(p_{h}\\) by adding the missing factor. %rax is already \\(p_{l}\\) .","title":"Solution"},{"location":"chapter3/3.60/","text":"3.60 Corrections: In C code, parameter n should be of type int , as per the assembly code. Problem Consider the following assembly code: long loop(long x, int n) x in %rdi, n in %esi 1 loop: 2 movl %esi, %ecx 3 movl $1, %edx 4 movl $0, %eax 5 jmp .L2 6 .L3: 7 movq %rdi, %r8 8 andq %rdx, %r8 9 orq %r8, %rax 10 salq %cl, %rdx 11 .L2: 12 testq %rdx, %rdx 13 jne .L3 14 rep; ret The preceding code was generated by compiling C code that had the following overall form: 1 long loop(long x, int n) 2 { 3 long result = _____; 4 long mask; 5 for (mask = _____; mask _____; mask = _____){ 6 result |= _____; 7 } 8 return result; 9 } Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables. A. Which registers hold program values x, n, result, and mask? B. What are the initial values of result and mask? C. What is the test condition for mask? D. How does mask get updated? E. How does result get updated? F. Fill in all the missing parts of the C code. Solution A. x \\(\\rightarrow\\) %rdi n \\(\\rightarrow\\) %esi result \\(\\rightarrow\\) %rax mask \\(\\rightarrow\\) %rdx B. result = 0, mask = 1 C. mask != 0 D. mask << n Note: In the assembly code, we see that only the lower 8 bytes of n ( %cl ) are taken. It is undefined behaviour in C as to what happens when a shift is attempted with a number greater than 32 or 64, but most processors would behave as if modulo 64 or modulo 32 that value was passed. E. result |= x & mask F. 1 long loop(long x, int n) 2 { 3 long result = 0; 4 long mask; 5 for (mask = 1; mask != 0; mask = mask << n){ 6 result |= x & mask; 7 } 8 return result; 9 }","title":"3.60"},{"location":"chapter3/3.60/#360","text":"Corrections: In C code, parameter n should be of type int , as per the assembly code.","title":"3.60"},{"location":"chapter3/3.60/#problem","text":"Consider the following assembly code: long loop(long x, int n) x in %rdi, n in %esi 1 loop: 2 movl %esi, %ecx 3 movl $1, %edx 4 movl $0, %eax 5 jmp .L2 6 .L3: 7 movq %rdi, %r8 8 andq %rdx, %r8 9 orq %r8, %rax 10 salq %cl, %rdx 11 .L2: 12 testq %rdx, %rdx 13 jne .L3 14 rep; ret The preceding code was generated by compiling C code that had the following overall form: 1 long loop(long x, int n) 2 { 3 long result = _____; 4 long mask; 5 for (mask = _____; mask _____; mask = _____){ 6 result |= _____; 7 } 8 return result; 9 } Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables. A. Which registers hold program values x, n, result, and mask? B. What are the initial values of result and mask? C. What is the test condition for mask? D. How does mask get updated? E. How does result get updated? F. Fill in all the missing parts of the C code.","title":"Problem"},{"location":"chapter3/3.60/#solution","text":"","title":"Solution"},{"location":"chapter3/3.60/#a","text":"x \\(\\rightarrow\\) %rdi n \\(\\rightarrow\\) %esi result \\(\\rightarrow\\) %rax mask \\(\\rightarrow\\) %rdx","title":"A."},{"location":"chapter3/3.60/#b","text":"result = 0, mask = 1","title":"B."},{"location":"chapter3/3.60/#c","text":"mask != 0","title":"C."},{"location":"chapter3/3.60/#d","text":"mask << n Note: In the assembly code, we see that only the lower 8 bytes of n ( %cl ) are taken. It is undefined behaviour in C as to what happens when a shift is attempted with a number greater than 32 or 64, but most processors would behave as if modulo 64 or modulo 32 that value was passed.","title":"D."},{"location":"chapter3/3.60/#e","text":"result |= x & mask","title":"E."},{"location":"chapter3/3.60/#f","text":"1 long loop(long x, int n) 2 { 3 long result = 0; 4 long mask; 5 for (mask = 1; mask != 0; mask = mask << n){ 6 result |= x & mask; 7 } 8 return result; 9 }","title":"F."},{"location":"chapter3/3.61/","text":"3.61 Problem In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer: long cread(long *xp) { return (xp ? *xp : 0); } We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address. Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions. Solution Any arguments to cmov* instruction will be executed. If we pass a reference to a null pointer, the deferencing will be attempted even if the condition is incorrect. Here we perform a conditional move with the pointer rather than the value it references. long cread_alt(long *xp) { long *zeroPtr = 0; long *resultPtr = xp != NULL ? xp : zeroPtr; return *resultPtr; }","title":"3.61"},{"location":"chapter3/3.61/#361","text":"","title":"3.61"},{"location":"chapter3/3.61/#problem","text":"In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer: long cread(long *xp) { return (xp ? *xp : 0); } We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address. Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.","title":"Problem"},{"location":"chapter3/3.61/#solution","text":"Any arguments to cmov* instruction will be executed. If we pass a reference to a null pointer, the deferencing will be attempted even if the condition is incorrect. Here we perform a conditional move with the pointer rather than the value it references. long cread_alt(long *xp) { long *zeroPtr = 0; long *resultPtr = xp != NULL ? xp : zeroPtr; return *resultPtr; }","title":"Solution"},{"location":"chapter3/3.62/","text":"3.62 Problem The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted. 1 /* Enumerated type creates set of constants numbered 0 and upward */ 2 typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; 3 4 long switch3(long *p1, long *p2, mode_t action) 5 { 6 long result = 0; 7 switch(action) { 8 case MODE_A: 9 10 case MODE_B: 11 12 case MODE_C: 13 14 case MODE_D: 15 16 case MODE_E: 17 18 default: 19 20 } 21 return result; 22 } The part of the generated assembly code implementing the different actions is shown in Figure 3.52. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations. p1 in %rdi, p2 in %rsi, action in %edx 1 .L8: MODE_E 2 movl $27, %eax 3 ret 4 .L3: MODE_A 5 movq (%rsi), %rax 6 movq (%rdi), %rdx 7 movq %rdx, (%rsi) 8 ret 9 .L5: MODE_B 10 movq (%rdi), %rax 11 addq (%rsi), %rax 12 movq %rax, (%rdi) 13 ret 14 .L6: MODE_C 15 movq $59, (%rdi) 16 movq (%rsi), %rax 17 ret 18 .L7: MODE_D 19 movq (%rsi), %rax 20 movq %rax, (%rdi) 21 movl $27, %eax 22 ret 23 .L9: default 24 movl $12, %eax 25 ret Fill in the missing parts of the C code. It contained one case that fell through to another\u2014try to reconstruct this. Solution Studying the assembly code, we can see that MODE_E and MODE_D have one step in common ( movl $27, %eax ). No other cases have a last step in common, and we can conclude that MODE_D was the case that fell through to MODE_E . /* Enumerated type creates set of constants numbered 0 and upward */ typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: result = *p1 + *p2; *p1 = result; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; case MODE_E: result = 27; break; default: result = 12; } return result; }","title":"3.62"},{"location":"chapter3/3.62/#362","text":"","title":"3.62"},{"location":"chapter3/3.62/#problem","text":"The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted. 1 /* Enumerated type creates set of constants numbered 0 and upward */ 2 typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; 3 4 long switch3(long *p1, long *p2, mode_t action) 5 { 6 long result = 0; 7 switch(action) { 8 case MODE_A: 9 10 case MODE_B: 11 12 case MODE_C: 13 14 case MODE_D: 15 16 case MODE_E: 17 18 default: 19 20 } 21 return result; 22 } The part of the generated assembly code implementing the different actions is shown in Figure 3.52. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations. p1 in %rdi, p2 in %rsi, action in %edx 1 .L8: MODE_E 2 movl $27, %eax 3 ret 4 .L3: MODE_A 5 movq (%rsi), %rax 6 movq (%rdi), %rdx 7 movq %rdx, (%rsi) 8 ret 9 .L5: MODE_B 10 movq (%rdi), %rax 11 addq (%rsi), %rax 12 movq %rax, (%rdi) 13 ret 14 .L6: MODE_C 15 movq $59, (%rdi) 16 movq (%rsi), %rax 17 ret 18 .L7: MODE_D 19 movq (%rsi), %rax 20 movq %rax, (%rdi) 21 movl $27, %eax 22 ret 23 .L9: default 24 movl $12, %eax 25 ret Fill in the missing parts of the C code. It contained one case that fell through to another\u2014try to reconstruct this.","title":"Problem"},{"location":"chapter3/3.62/#solution","text":"Studying the assembly code, we can see that MODE_E and MODE_D have one step in common ( movl $27, %eax ). No other cases have a last step in common, and we can conclude that MODE_D was the case that fell through to MODE_E . /* Enumerated type creates set of constants numbered 0 and upward */ typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: result = *p1 + *p2; *p1 = result; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; case MODE_E: result = 27; break; default: result = 12; } return result; }","title":"Solution"},{"location":"chapter3/3.63/","text":"3.63 Solution long switch_prob(long x, long n) x in %rdi, n in %rsi 1 0000000000400590 <switch_prob>: 2 400590: 48 83 ee 3c sub $0x3c,%rsi # n - 60 3 400594: 48 83 fe 05 cmp $0x5,%rsi # compare n-60:5 4 400598: 77 29 ja 4005c3 <switch_prob+0x33> # if n-60 > 5, goto line 17 5 40059a: ff 24 f5 f8 06 40 00 jmpq *0x4006f8(,%rsi,8) # use lookup table to go to case code 6 4005a1: 48 8d 04 fd 00 00 00 lea 0x0(,%rdi,8),%rax result = 8*x 7 4005a8: 00 # noop 8 4005a9: c3 retq 9 4005aa: 4889f8 mov %rdi,%rax # result = x 10 4005ad: 48 c1 f8 03 sar $0x3,%rax # result >>= 3 11 4005b1: c3 retq 12 4005b2: 4889f8 mov %rdi,%rax # result = x 13 4005b5: 48 c1 e0 04 shl $0x4,%rax # result <<= 4 14 4005b9: 4829f8 sub %rdi,%rax # result -= x 15 4005bc: 4889c7 mov %rax,%rdi # x = result 16 4005bf: 48 0f af ff imul %rdi,%rdi # x = x* x 17 4005c3: 48 8d 47 4b lea 0x4b(%rdi),%rax # x + 75 18 4005c7: c3 retq Solution code: long switch_prob(long x, long n) { long result = x; switch(n) { case 60: case 62: result = 8 * x; break; case 63: result = x >> 3; break; case 64: x = (x << 4) - x; case 65: x = x * x; default: result = x + 75 } return result; }","title":"3.63"},{"location":"chapter3/3.63/#363","text":"","title":"3.63"},{"location":"chapter3/3.63/#solution","text":"long switch_prob(long x, long n) x in %rdi, n in %rsi 1 0000000000400590 <switch_prob>: 2 400590: 48 83 ee 3c sub $0x3c,%rsi # n - 60 3 400594: 48 83 fe 05 cmp $0x5,%rsi # compare n-60:5 4 400598: 77 29 ja 4005c3 <switch_prob+0x33> # if n-60 > 5, goto line 17 5 40059a: ff 24 f5 f8 06 40 00 jmpq *0x4006f8(,%rsi,8) # use lookup table to go to case code 6 4005a1: 48 8d 04 fd 00 00 00 lea 0x0(,%rdi,8),%rax result = 8*x 7 4005a8: 00 # noop 8 4005a9: c3 retq 9 4005aa: 4889f8 mov %rdi,%rax # result = x 10 4005ad: 48 c1 f8 03 sar $0x3,%rax # result >>= 3 11 4005b1: c3 retq 12 4005b2: 4889f8 mov %rdi,%rax # result = x 13 4005b5: 48 c1 e0 04 shl $0x4,%rax # result <<= 4 14 4005b9: 4829f8 sub %rdi,%rax # result -= x 15 4005bc: 4889c7 mov %rax,%rdi # x = result 16 4005bf: 48 0f af ff imul %rdi,%rdi # x = x* x 17 4005c3: 48 8d 47 4b lea 0x4b(%rdi),%rax # x + 75 18 4005c7: c3 retq Solution code: long switch_prob(long x, long n) { long result = x; switch(n) { case 60: case 62: result = 8 * x; break; case 63: result = x >> 3; break; case 64: x = (x << 4) - x; case 65: x = x * x; default: result = x + 75 } return result; }","title":"Solution"},{"location":"chapter3/3.64/","text":"3.64 Solution A. Array long A[R][S][T] An element A[i][j][k] would have an offset = space taken by i 3d rows + space taken by j 2d rows + space taken by k long data. \\[ A_{i,j,k} = i \\cdot S \\cdot T \\cdot L + j \\cdot T \\cdot L + k \\cdot L \\] where L is the size of the data type. Here, L is 8 bytes. We get \\[ A_{i,j,k} = 8 \\cdot (i \\cdot S \\cdot T + j \\cdot T + k) \\] B. From the assembly code, we get \\[ A[i][j][k] = A + 65 \\cdot i + 13 \\cdot j + k \\] Comparing coefficients from the earlier equation, we get \\(65 = S \\cdot T\\) and \\(13 = T\\) . Thus, \\(S = 5\\) and \\(T = 13\\) . And, the total size of the array is 3640. \\[ R \\cdot S \\cdot T \\cdot L = 3640 \\] \\[ R = 3640 \\div (5 \\cdot 13 \\cdot 8) \\] \\(R = 7\\) , \\(S = 5\\) and \\(T = 13\\) .","title":"3.64"},{"location":"chapter3/3.64/#364","text":"","title":"3.64"},{"location":"chapter3/3.64/#solution","text":"","title":"Solution"},{"location":"chapter3/3.64/#a","text":"Array long A[R][S][T] An element A[i][j][k] would have an offset = space taken by i 3d rows + space taken by j 2d rows + space taken by k long data. \\[ A_{i,j,k} = i \\cdot S \\cdot T \\cdot L + j \\cdot T \\cdot L + k \\cdot L \\] where L is the size of the data type. Here, L is 8 bytes. We get \\[ A_{i,j,k} = 8 \\cdot (i \\cdot S \\cdot T + j \\cdot T + k) \\]","title":"A."},{"location":"chapter3/3.64/#b","text":"From the assembly code, we get \\[ A[i][j][k] = A + 65 \\cdot i + 13 \\cdot j + k \\] Comparing coefficients from the earlier equation, we get \\(65 = S \\cdot T\\) and \\(13 = T\\) . Thus, \\(S = 5\\) and \\(T = 13\\) . And, the total size of the array is 3640. \\[ R \\cdot S \\cdot T \\cdot L = 3640 \\] \\[ R = 3640 \\div (5 \\cdot 13 \\cdot 8) \\] \\(R = 7\\) , \\(S = 5\\) and \\(T = 13\\) .","title":"B."},{"location":"chapter3/3.65/","text":"3.65 A %rdx B %rax C 15 The pointer that goes column-wise has to be incremented by a value that is equivalent to the size of one full row. Each element is 8 bytes long, so we get \\(120 \\div 8 = 15\\) .","title":"3.65"},{"location":"chapter3/3.65/#365","text":"","title":"3.65"},{"location":"chapter3/3.65/#a","text":"%rdx","title":"A"},{"location":"chapter3/3.65/#b","text":"%rax","title":"B"},{"location":"chapter3/3.65/#c","text":"15 The pointer that goes column-wise has to be incremented by a value that is equivalent to the size of one full row. Each element is 8 bytes long, so we get \\(120 \\div 8 = 15\\) .","title":"C"},{"location":"chapter3/3.66/","text":"3.66 Solution Annotating the assembly code, long sum_col(long n, long A[NR(n)][NC(n)], long j) n in %rdi, A in %rsi, j in %rdx 1 sum_col: 2 leaq 1(,%rdi,4), %r8 %r8 <- 4n + 1 3 leaq (%rdi,%rdi,2), %rax %rax <- 3n 4 movq %rax, %rdi %rdi <- %rax 5 testq %rax, %rax like %rax & %rax 6 jle .L4 %rax <= 0 ? 7 salq $3, %r8 %r8 *= 8 8 leaq (%rsi,%rdx,8), %rcx ptr = A + 8*j 9 movl $0, %eax %rax <- 0 10 movl $0, %edx %rdx <- 0 11 .L3: 12 addq (%rcx), %rax result += *ptr 13 addq $1, %rdx %rdx += 1 (%rdx is i) 14 addq %r8, %rcx ptr += (4n+1)*8 15 cmpq %rdi, %rdx compare i:3n 16 jne .L3 if i != 3n, loop 17 rep; ret 18 .L4: 19 movl $0, %eax result = 0 20 ret From lines 10, 13 and 15, we can see that i goes from 0 to 3n with a step of 1. From the stopping condition, we get that NR(n) must be 3n . On line 14, we can see that the pointer is being moved ahead by \\((4n+1) \\cdot 8\\) bytes on each iteration. Because 8 is the number of bytes taken by a long , we get that \\(4n+1\\) is the number of columns in the array. NR(n) = 3n NC(n) = 4n + 1","title":"3.66"},{"location":"chapter3/3.66/#366","text":"","title":"3.66"},{"location":"chapter3/3.66/#solution","text":"Annotating the assembly code, long sum_col(long n, long A[NR(n)][NC(n)], long j) n in %rdi, A in %rsi, j in %rdx 1 sum_col: 2 leaq 1(,%rdi,4), %r8 %r8 <- 4n + 1 3 leaq (%rdi,%rdi,2), %rax %rax <- 3n 4 movq %rax, %rdi %rdi <- %rax 5 testq %rax, %rax like %rax & %rax 6 jle .L4 %rax <= 0 ? 7 salq $3, %r8 %r8 *= 8 8 leaq (%rsi,%rdx,8), %rcx ptr = A + 8*j 9 movl $0, %eax %rax <- 0 10 movl $0, %edx %rdx <- 0 11 .L3: 12 addq (%rcx), %rax result += *ptr 13 addq $1, %rdx %rdx += 1 (%rdx is i) 14 addq %r8, %rcx ptr += (4n+1)*8 15 cmpq %rdi, %rdx compare i:3n 16 jne .L3 if i != 3n, loop 17 rep; ret 18 .L4: 19 movl $0, %eax result = 0 20 ret From lines 10, 13 and 15, we can see that i goes from 0 to 3n with a step of 1. From the stopping condition, we get that NR(n) must be 3n . On line 14, we can see that the pointer is being moved ahead by \\((4n+1) \\cdot 8\\) bytes on each iteration. Because 8 is the number of bytes taken by a long , we get that \\(4n+1\\) is the number of columns in the array. NR(n) = 3n NC(n) = 4n + 1","title":"Solution"},{"location":"chapter3/3.67/","text":"3.67 Solution A. B. stack pointer + 64 C. Relative to the stack pointer. But there is an extra offset of 8 added due to call (occupied by the return address), so an offset of 24 from %rsp would refer to s.p from the answer to A, and s.a[0] would be at an offset of 8. D. By moving elements of s to addresses relative to the argument. E. F. Structs can be passed as part of the \"Argument build\" area on the stack frame of the caller. The argument that is passed in %rdi register was the memory address of where the return struct should be stored. The space for it was allocated by the caller before hand. This was also the address that was returned.","title":"3.67"},{"location":"chapter3/3.67/#367","text":"","title":"3.67"},{"location":"chapter3/3.67/#solution","text":"","title":"Solution"},{"location":"chapter3/3.67/#a","text":"","title":"A."},{"location":"chapter3/3.67/#b","text":"stack pointer + 64","title":"B."},{"location":"chapter3/3.67/#c","text":"Relative to the stack pointer. But there is an extra offset of 8 added due to call (occupied by the return address), so an offset of 24 from %rsp would refer to s.p from the answer to A, and s.a[0] would be at an offset of 8.","title":"C."},{"location":"chapter3/3.67/#d","text":"By moving elements of s to addresses relative to the argument.","title":"D."},{"location":"chapter3/3.67/#e","text":"","title":"E."},{"location":"chapter3/3.67/#f","text":"Structs can be passed as part of the \"Argument build\" area on the stack frame of the caller. The argument that is passed in %rdi register was the memory address of where the return struct should be stored. The space for it was allocated by the caller before hand. This was also the address that was returned.","title":"F."},{"location":"chapter3/3.68/","text":"3.68 Solution Annotating the assembly code: void setVal(str1 *p, str2 *q) p in %rdi, q in %rsi 1 setVal: 2 movslq 8(%rsi), %rax # %rax = (long) q.t 3 addq 32(%rsi), %rax # %rax += q.u 4 movq %rax, 184(%rdi) # p.y = %rax 5 ret From the assembly code and C code, we can make the observations that: q.t is at an offset of 8 from start of q. \\(\\implies\\) length of str2.array ( \\(B\\) ) is between 5 and 8 inclusive due to the padding for t . \\(\\implies\\) At offset 12, q.t ends and q.s starts q.u is at an offset of 32 from the start of q. \\(\\implies\\) q.s stretched from offset 12 to between 25 and 32 inclusive, for the padding to match. p.y is at an offset of 184 from the start of p . \\(\\implies\\) Array x occupied somewhere between 177 and 184 bytes. Putting all 3 inequalities in mathematical form, we get: \\[ 5 <= B <= 8, 13 <= 2 \\cdot A <= 20,\\ 177 <= 4 \\cdot A \\cdot B <= 184 \\] \\[ 7 <= A <= 10\\ \\text{, dividing 2nd inequality by 2} \\] Divding 3rd inequality by 4: \\[ 45 <= A \\cdot B <= 46 \\] Two cases: Case 1: \\(A \\cdot B = 45\\) Valid values for (A, B): (9, 5) Case 2: \\(A \\cdot B = 46\\) No valid values possible in this case because \\(46 = 23 \\cdot 2\\) and 23 is a prime. We can conclude that A = 9 and B = 5 .","title":"3.68"},{"location":"chapter3/3.68/#368","text":"","title":"3.68"},{"location":"chapter3/3.68/#solution","text":"Annotating the assembly code: void setVal(str1 *p, str2 *q) p in %rdi, q in %rsi 1 setVal: 2 movslq 8(%rsi), %rax # %rax = (long) q.t 3 addq 32(%rsi), %rax # %rax += q.u 4 movq %rax, 184(%rdi) # p.y = %rax 5 ret From the assembly code and C code, we can make the observations that: q.t is at an offset of 8 from start of q. \\(\\implies\\) length of str2.array ( \\(B\\) ) is between 5 and 8 inclusive due to the padding for t . \\(\\implies\\) At offset 12, q.t ends and q.s starts q.u is at an offset of 32 from the start of q. \\(\\implies\\) q.s stretched from offset 12 to between 25 and 32 inclusive, for the padding to match. p.y is at an offset of 184 from the start of p . \\(\\implies\\) Array x occupied somewhere between 177 and 184 bytes. Putting all 3 inequalities in mathematical form, we get: \\[ 5 <= B <= 8, 13 <= 2 \\cdot A <= 20,\\ 177 <= 4 \\cdot A \\cdot B <= 184 \\] \\[ 7 <= A <= 10\\ \\text{, dividing 2nd inequality by 2} \\] Divding 3rd inequality by 4: \\[ 45 <= A \\cdot B <= 46 \\] Two cases: Case 1: \\(A \\cdot B = 45\\) Valid values for (A, B): (9, 5) Case 2: \\(A \\cdot B = 46\\) No valid values possible in this case because \\(46 = 23 \\cdot 2\\) and 23 is a prime. We can conclude that A = 9 and B = 5 .","title":"Solution"}]}