{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kaustubh's solutions to CS:APP problems This static website has my solutions to the homework problems of the book \"Computer Systems: A Programmer's Perspective\". Each problem is a markdown file, and all content is on this GitHub repository . The content index can be viewed on the left sidebar of this page.","title":"Kaustubh's solutions to CS:APP problems"},{"location":"#kaustubhs-solutions-to-csapp-problems","text":"This static website has my solutions to the homework problems of the book \"Computer Systems: A Programmer's Perspective\". Each problem is a markdown file, and all content is on this GitHub repository . The content index can be viewed on the left sidebar of this page.","title":"Kaustubh's solutions to CS:APP problems"},{"location":"chapter3/3.58/","text":"3.58 Problem For a function with prototype long decode2(long x, long y, long z); gcc generates the following assembly code: 1 decode2: 2 subq %rdx, %rsi 3 imulq %rsi, %rdi 4 movq %rsi, %rax 5 salq $63, %rax 6 sarq $63, %rax 7 xorq %rdi, %rax 8 ret Parameters x, y, and z are passed in registers %rdi , %rsi , and %rdx . The code stores the return value in register %rax . Write C code for decode2 that will have an effect equivalent to the assembly code shown. Solution decode2 first computes the value (y - z) * x (let's call it k ), and then converts it to a value whose bit representation contains either all 1s (if k is odd) or all 0s (if k is even). long decode2(long x, long y, long z) { long k = (y - z) * x; k = (k << 63) >> 63; return k ^ x; } Interesting point: In terms of x , what are the two values that this function can return?","title":"3.58"},{"location":"chapter3/3.58/#358","text":"","title":"3.58"},{"location":"chapter3/3.58/#problem","text":"For a function with prototype long decode2(long x, long y, long z); gcc generates the following assembly code: 1 decode2: 2 subq %rdx, %rsi 3 imulq %rsi, %rdi 4 movq %rsi, %rax 5 salq $63, %rax 6 sarq $63, %rax 7 xorq %rdi, %rax 8 ret Parameters x, y, and z are passed in registers %rdi , %rsi , and %rdx . The code stores the return value in register %rax . Write C code for decode2 that will have an effect equivalent to the assembly code shown.","title":"Problem"},{"location":"chapter3/3.58/#solution","text":"decode2 first computes the value (y - z) * x (let's call it k ), and then converts it to a value whose bit representation contains either all 1s (if k is odd) or all 0s (if k is even). long decode2(long x, long y, long z) { long k = (y - z) * x; k = (k << 63) >> 63; return k ^ x; } Interesting point: In terms of x , what are the two values that this function can return?","title":"Solution"},{"location":"chapter3/3.59/","text":"3.59 Problem The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory: 1 typedef __int128 int128_t; 2 3 void store_prod(int128_t *dest, int64_t x, int64_t y) { 4 *dest = x * (int128_t) y; 5 } Gcc generates the following assembly code implementing the computation: 1 store_prod: 2 movq %rdx, %rax 3 cqto 4 movq %rsi, %rcx 5 sarq $63, %rcx 6 imulq %rax, %rcx 7 imulq %rsi, %rdx 8 addq %rdx, %rcx 9 mulq %rsi 10 addq %rcx, %rdx 11 movq %rax, (%rdi) 12 movq %rdx, 8(%rdi) 13 ret This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as x = 264 \u00b7 x h + x l and y = 264 \u00b7 y h + y<sub<l , where x h , x l , y h , and y<sub<l are 64-bit values. Similarly, the 128-bit product can be written as p = 264 \u00b7 ph + pl, where ph and pl are 64-bit values. Show how the code computes the values of ph and pl in terms of x h , x l , y h , and y<sub<l . Solution While reading the assembly code, it's important to remember that the mulq instruction computes a 128-bit result stored in %rdx:%rax% . That is, the high 64 bits in %rdx and the low 64 bits in %rax . \\[ x = 2^{64} \\cdot x_{h} + x_{l},\\ y = 2^{64} \\cdot y_{h} + y_{l} \\] \\[ x \\cdot y = (2^{64} \\cdot x_{h} + x_{l}) \\cdot (2^{64} \\cdot y_{h} + y_{l}) \\] \\[ x \\cdot y = 2^{128} \\cdot x_{h} \\cdot y_{h} + 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] We can ignore the term with \\(2^{128}\\) because it cannot fit in 128 bits, and we'd end up with the remainder. Since \\(p\\) can also be represented similarly in terms of \\(p_{h}\\) and \\(p_{l}\\) , we get \\[ p = 2^{64} \\cdot p_{h} + p_{l} \\] \\[ 2^{64} \\cdot p_{h} + p_{l} = 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] Besides the coefficient of \\(2^{64}\\) on the right hand side, \\(x_{l} \\cdot y_{l}\\) can also add to the value of \\(p_{h}\\) . So, we get: \\[ p_{h} = x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l} + quotient(x_{l} \\cdot y_{l},\\ 2^{64}) \\] And, \\[ p_{l} = (x_{l} \\cdot y_{l}) \\bmod 2^{64} \\] This is reflected in our assembly code, we sign extend both \\(x\\) (to %rdx:%rax with line 2 cqto ) and \\(y\\) (to %rcx:%rsi after line 5 sarq ). We first calculate the value of \\(p_{h}\\) without considering the factor from \\(x_{l} \\cdot y_{l}\\) (after line 8) in %rcx . The mulq instruction then sets %rax and %rdx to the low and high 64-bits of \\(x_{l} \\cdot y_{l}\\) respectively. We then add %rcx to %rdx to get \\(p_{h}\\) by adding the missing factor. %rax is already \\(p_{l}\\) .","title":"3.59"},{"location":"chapter3/3.59/#359","text":"","title":"3.59"},{"location":"chapter3/3.59/#problem","text":"The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory: 1 typedef __int128 int128_t; 2 3 void store_prod(int128_t *dest, int64_t x, int64_t y) { 4 *dest = x * (int128_t) y; 5 } Gcc generates the following assembly code implementing the computation: 1 store_prod: 2 movq %rdx, %rax 3 cqto 4 movq %rsi, %rcx 5 sarq $63, %rcx 6 imulq %rax, %rcx 7 imulq %rsi, %rdx 8 addq %rdx, %rcx 9 mulq %rsi 10 addq %rcx, %rdx 11 movq %rax, (%rdi) 12 movq %rdx, 8(%rdi) 13 ret This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as x = 264 \u00b7 x h + x l and y = 264 \u00b7 y h + y<sub<l , where x h , x l , y h , and y<sub<l are 64-bit values. Similarly, the 128-bit product can be written as p = 264 \u00b7 ph + pl, where ph and pl are 64-bit values. Show how the code computes the values of ph and pl in terms of x h , x l , y h , and y<sub<l .","title":"Problem"},{"location":"chapter3/3.59/#solution","text":"While reading the assembly code, it's important to remember that the mulq instruction computes a 128-bit result stored in %rdx:%rax% . That is, the high 64 bits in %rdx and the low 64 bits in %rax . \\[ x = 2^{64} \\cdot x_{h} + x_{l},\\ y = 2^{64} \\cdot y_{h} + y_{l} \\] \\[ x \\cdot y = (2^{64} \\cdot x_{h} + x_{l}) \\cdot (2^{64} \\cdot y_{h} + y_{l}) \\] \\[ x \\cdot y = 2^{128} \\cdot x_{h} \\cdot y_{h} + 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] We can ignore the term with \\(2^{128}\\) because it cannot fit in 128 bits, and we'd end up with the remainder. Since \\(p\\) can also be represented similarly in terms of \\(p_{h}\\) and \\(p_{l}\\) , we get \\[ p = 2^{64} \\cdot p_{h} + p_{l} \\] \\[ 2^{64} \\cdot p_{h} + p_{l} = 2^{64} \\cdot (x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l}) + x_{l} \\cdot y_{l} \\] Besides the coefficient of \\(2^{64}\\) on the right hand side, \\(x_{l} \\cdot y_{l}\\) can also add to the value of \\(p_{h}\\) . So, we get: \\[ p_{h} = x_{h} \\cdot y_{l} + y_{h} \\cdot x_{l} + quotient(x_{l} \\cdot y_{l},\\ 2^{64}) \\] And, \\[ p_{l} = (x_{l} \\cdot y_{l}) \\bmod 2^{64} \\] This is reflected in our assembly code, we sign extend both \\(x\\) (to %rdx:%rax with line 2 cqto ) and \\(y\\) (to %rcx:%rsi after line 5 sarq ). We first calculate the value of \\(p_{h}\\) without considering the factor from \\(x_{l} \\cdot y_{l}\\) (after line 8) in %rcx . The mulq instruction then sets %rax and %rdx to the low and high 64-bits of \\(x_{l} \\cdot y_{l}\\) respectively. We then add %rcx to %rdx to get \\(p_{h}\\) by adding the missing factor. %rax is already \\(p_{l}\\) .","title":"Solution"},{"location":"chapter3/3.60/","text":"3.60 Corrections: In C code, parameter n should be of type int , as per the assembly code. Problem Consider the following assembly code: long loop(long x, int n) x in %rdi, n in %esi 1 loop: 2 movl %esi, %ecx 3 movl $1, %edx 4 movl $0, %eax 5 jmp .L2 6 .L3: 7 movq %rdi, %r8 8 andq %rdx, %r8 9 orq %r8, %rax 10 salq %cl, %rdx 11 .L2: 12 testq %rdx, %rdx 13 jne .L3 14 rep; ret The preceding code was generated by compiling C code that had the following overall form: 1 long loop(long x, int n) 2 { 3 long result = _____; 4 long mask; 5 for (mask = _____; mask _____; mask = _____){ 6 result |= _____; 7 } 8 return result; 9 } Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables. A. Which registers hold program values x, n, result, and mask? B. What are the initial values of result and mask? C. What is the test condition for mask? D. How does mask get updated? E. How does result get updated? F. Fill in all the missing parts of the C code. Solution A. x \\(\\rightarrow\\) %rdi n \\(\\rightarrow\\) %esi result \\(\\rightarrow\\) %rax mask \\(\\rightarrow\\) %rdx B. result = 0, mask = 1 C. mask != 0 D. mask << n Note: In the assembly code, we see that only the lower 8 bytes of n ( %cl ) are taken. It is undefined behaviour in C as to what happens when a shift is attempted with a number greater than 32 or 64, but most processors would behave as if modulo 64 or modulo 32 that value was passed. E. result |= x & mask F. 1 long loop(long x, int n) 2 { 3 long result = 0; 4 long mask; 5 for (mask = 1; mask != 0; mask = mask << n){ 6 result |= x & mask; 7 } 8 return result; 9 }","title":"3.60"},{"location":"chapter3/3.60/#360","text":"Corrections: In C code, parameter n should be of type int , as per the assembly code.","title":"3.60"},{"location":"chapter3/3.60/#problem","text":"Consider the following assembly code: long loop(long x, int n) x in %rdi, n in %esi 1 loop: 2 movl %esi, %ecx 3 movl $1, %edx 4 movl $0, %eax 5 jmp .L2 6 .L3: 7 movq %rdi, %r8 8 andq %rdx, %r8 9 orq %r8, %rax 10 salq %cl, %rdx 11 .L2: 12 testq %rdx, %rdx 13 jne .L3 14 rep; ret The preceding code was generated by compiling C code that had the following overall form: 1 long loop(long x, int n) 2 { 3 long result = _____; 4 long mask; 5 for (mask = _____; mask _____; mask = _____){ 6 result |= _____; 7 } 8 return result; 9 } Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables. A. Which registers hold program values x, n, result, and mask? B. What are the initial values of result and mask? C. What is the test condition for mask? D. How does mask get updated? E. How does result get updated? F. Fill in all the missing parts of the C code.","title":"Problem"},{"location":"chapter3/3.60/#solution","text":"","title":"Solution"},{"location":"chapter3/3.60/#a","text":"x \\(\\rightarrow\\) %rdi n \\(\\rightarrow\\) %esi result \\(\\rightarrow\\) %rax mask \\(\\rightarrow\\) %rdx","title":"A."},{"location":"chapter3/3.60/#b","text":"result = 0, mask = 1","title":"B."},{"location":"chapter3/3.60/#c","text":"mask != 0","title":"C."},{"location":"chapter3/3.60/#d","text":"mask << n Note: In the assembly code, we see that only the lower 8 bytes of n ( %cl ) are taken. It is undefined behaviour in C as to what happens when a shift is attempted with a number greater than 32 or 64, but most processors would behave as if modulo 64 or modulo 32 that value was passed.","title":"D."},{"location":"chapter3/3.60/#e","text":"result |= x & mask","title":"E."},{"location":"chapter3/3.60/#f","text":"1 long loop(long x, int n) 2 { 3 long result = 0; 4 long mask; 5 for (mask = 1; mask != 0; mask = mask << n){ 6 result |= x & mask; 7 } 8 return result; 9 }","title":"F."},{"location":"chapter3/3.61/","text":"3.61 Problem In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer: long cread(long *xp) { return (xp ? *xp : 0); } We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address. Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions. Solution Any arguments to cmov* instruction will be executed. If we pass a reference to a null pointer, the deferencing will be attempted even if the condition is incorrect. Here we perform a conditional move with the pointer rather than the value it references. long cread_alt(long *xp) { long *zeroPtr = 0; long *resultPtr = xp != NULL ? xp : zeroPtr; return *resultPtr; }","title":"3.61"},{"location":"chapter3/3.61/#361","text":"","title":"3.61"},{"location":"chapter3/3.61/#problem","text":"In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer: long cread(long *xp) { return (xp ? *xp : 0); } We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address. Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.","title":"Problem"},{"location":"chapter3/3.61/#solution","text":"Any arguments to cmov* instruction will be executed. If we pass a reference to a null pointer, the deferencing will be attempted even if the condition is incorrect. Here we perform a conditional move with the pointer rather than the value it references. long cread_alt(long *xp) { long *zeroPtr = 0; long *resultPtr = xp != NULL ? xp : zeroPtr; return *resultPtr; }","title":"Solution"},{"location":"chapter3/3.62/","text":"3.62 Problem The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted. 1 /* Enumerated type creates set of constants numbered 0 and upward */ 2 typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; 3 4 long switch3(long *p1, long *p2, mode_t action) 5 { 6 long result = 0; 7 switch(action) { 8 case MODE_A: 9 10 case MODE_B: 11 12 case MODE_C: 13 14 case MODE_D: 15 16 case MODE_E: 17 18 default: 19 20 } 21 return result; 22 } The part of the generated assembly code implementing the different actions is shown in Figure 3.52. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations. p1 in %rdi, p2 in %rsi, action in %edx 1 .L8: MODE_E 2 movl $27, %eax 3 ret 4 .L3: MODE_A 5 movq (%rsi), %rax 6 movq (%rdi), %rdx 7 movq %rdx, (%rsi) 8 ret 9 .L5: MODE_B 10 movq (%rdi), %rax 11 addq (%rsi), %rax 12 movq %rax, (%rdi) 13 ret 14 .L6: MODE_C 15 movq $59, (%rdi) 16 movq (%rsi), %rax 17 ret 18 .L7: MODE_D 19 movq (%rsi), %rax 20 movq %rax, (%rdi) 21 movl $27, %eax 22 ret 23 .L9: default 24 movl $12, %eax 25 ret Fill in the missing parts of the C code. It contained one case that fell through to another\u2014try to reconstruct this. Solution Studying the assembly code, we can see that MODE_E and MODE_D have one step in common ( movl $27, %eax ). No other cases have a last step in common, and we can conclude that MODE_D was the case that fell through to MODE_E . /* Enumerated type creates set of constants numbered 0 and upward */ typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: result = *p1 + *p2; *p1 = result; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; case MODE_E: result = 27; break; default: result = 12; } return result; }","title":"3.62"},{"location":"chapter3/3.62/#362","text":"","title":"3.62"},{"location":"chapter3/3.62/#problem","text":"The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted. 1 /* Enumerated type creates set of constants numbered 0 and upward */ 2 typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; 3 4 long switch3(long *p1, long *p2, mode_t action) 5 { 6 long result = 0; 7 switch(action) { 8 case MODE_A: 9 10 case MODE_B: 11 12 case MODE_C: 13 14 case MODE_D: 15 16 case MODE_E: 17 18 default: 19 20 } 21 return result; 22 } The part of the generated assembly code implementing the different actions is shown in Figure 3.52. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations. p1 in %rdi, p2 in %rsi, action in %edx 1 .L8: MODE_E 2 movl $27, %eax 3 ret 4 .L3: MODE_A 5 movq (%rsi), %rax 6 movq (%rdi), %rdx 7 movq %rdx, (%rsi) 8 ret 9 .L5: MODE_B 10 movq (%rdi), %rax 11 addq (%rsi), %rax 12 movq %rax, (%rdi) 13 ret 14 .L6: MODE_C 15 movq $59, (%rdi) 16 movq (%rsi), %rax 17 ret 18 .L7: MODE_D 19 movq (%rsi), %rax 20 movq %rax, (%rdi) 21 movl $27, %eax 22 ret 23 .L9: default 24 movl $12, %eax 25 ret Fill in the missing parts of the C code. It contained one case that fell through to another\u2014try to reconstruct this.","title":"Problem"},{"location":"chapter3/3.62/#solution","text":"Studying the assembly code, we can see that MODE_E and MODE_D have one step in common ( movl $27, %eax ). No other cases have a last step in common, and we can conclude that MODE_D was the case that fell through to MODE_E . /* Enumerated type creates set of constants numbered 0 and upward */ typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t; long switch3(long *p1, long *p2, mode_t action) { long result = 0; switch(action) { case MODE_A: result = *p2; *p2 = *p1; break; case MODE_B: result = *p1 + *p2; *p1 = result; break; case MODE_C: *p1 = 59; result = *p2; break; case MODE_D: *p1 = *p2; case MODE_E: result = 27; break; default: result = 12; } return result; }","title":"Solution"},{"location":"chapter3/3.63/","text":"3.63 Solution long switch_prob(long x, long n) x in %rdi, n in %rsi 1 0000000000400590 <switch_prob>: 2 400590: 48 83 ee 3c sub $0x3c,%rsi # n - 60 3 400594: 48 83 fe 05 cmp $0x5,%rsi # compare n-60:5 4 400598: 77 29 ja 4005c3 <switch_prob+0x33> # if n-60 > 5, goto line 17 5 40059a: ff 24 f5 f8 06 40 00 jmpq *0x4006f8(,%rsi,8) # use lookup table to go to case code 6 4005a1: 48 8d 04 fd 00 00 00 lea 0x0(,%rdi,8),%rax result = 8*x 7 4005a8: 00 # noop 8 4005a9: c3 retq 9 4005aa: 4889f8 mov %rdi,%rax # result = x 10 4005ad: 48 c1 f8 03 sar $0x3,%rax # result >>= 3 11 4005b1: c3 retq 12 4005b2: 4889f8 mov %rdi,%rax # result = x 13 4005b5: 48 c1 e0 04 shl $0x4,%rax # result <<= 4 14 4005b9: 4829f8 sub %rdi,%rax # result -= x 15 4005bc: 4889c7 mov %rax,%rdi # x = result 16 4005bf: 48 0f af ff imul %rdi,%rdi # x = x* x 17 4005c3: 48 8d 47 4b lea 0x4b(%rdi),%rax # x + 75 18 4005c7: c3 retq Solution code: long switch_prob(long x, long n) { long result = x; switch(n) { case 60: case 62: result = 8 * x; break; case 63: result = x >> 3; break; case 64: x = (x << 4) - x; case 65: x = x * x; default: result = x + 75 } return result; }","title":"3.63"},{"location":"chapter3/3.63/#363","text":"","title":"3.63"},{"location":"chapter3/3.63/#solution","text":"long switch_prob(long x, long n) x in %rdi, n in %rsi 1 0000000000400590 <switch_prob>: 2 400590: 48 83 ee 3c sub $0x3c,%rsi # n - 60 3 400594: 48 83 fe 05 cmp $0x5,%rsi # compare n-60:5 4 400598: 77 29 ja 4005c3 <switch_prob+0x33> # if n-60 > 5, goto line 17 5 40059a: ff 24 f5 f8 06 40 00 jmpq *0x4006f8(,%rsi,8) # use lookup table to go to case code 6 4005a1: 48 8d 04 fd 00 00 00 lea 0x0(,%rdi,8),%rax result = 8*x 7 4005a8: 00 # noop 8 4005a9: c3 retq 9 4005aa: 4889f8 mov %rdi,%rax # result = x 10 4005ad: 48 c1 f8 03 sar $0x3,%rax # result >>= 3 11 4005b1: c3 retq 12 4005b2: 4889f8 mov %rdi,%rax # result = x 13 4005b5: 48 c1 e0 04 shl $0x4,%rax # result <<= 4 14 4005b9: 4829f8 sub %rdi,%rax # result -= x 15 4005bc: 4889c7 mov %rax,%rdi # x = result 16 4005bf: 48 0f af ff imul %rdi,%rdi # x = x* x 17 4005c3: 48 8d 47 4b lea 0x4b(%rdi),%rax # x + 75 18 4005c7: c3 retq Solution code: long switch_prob(long x, long n) { long result = x; switch(n) { case 60: case 62: result = 8 * x; break; case 63: result = x >> 3; break; case 64: x = (x << 4) - x; case 65: x = x * x; default: result = x + 75 } return result; }","title":"Solution"},{"location":"chapter3/3.64/","text":"3.64 Solution A. Array long A[R][S][T] An element A[i][j][k] would have an offset = space taken by i 3d rows + space taken by j 2d rows + space taken by k long data. \\[ A_{i,j,k} = i \\cdot S \\cdot T \\cdot L + j \\cdot T \\cdot L + k \\cdot L \\] where L is the size of the data type. Here, L is 8 bytes. We get \\[ A_{i,j,k} = 8 \\cdot (i \\cdot S \\cdot T + j \\cdot T + k) \\] B. From the assembly code, we get \\[ A[i][j][k] = A + 65 \\cdot i + 13 \\cdot j + k \\] Comparing coefficients from the earlier equation, we get \\(65 = S \\cdot T\\) and \\(13 = T\\) . Thus, \\(S = 5\\) and \\(T = 13\\) . And, the total size of the array is 3640. \\[ R \\cdot S \\cdot T \\cdot L = 3640 \\] \\[ R = 3640 \\div (5 \\cdot 13 \\cdot 8) \\] \\(R = 7\\) , \\(S = 5\\) and \\(T = 13\\) .","title":"3.64"},{"location":"chapter3/3.64/#364","text":"","title":"3.64"},{"location":"chapter3/3.64/#solution","text":"","title":"Solution"},{"location":"chapter3/3.64/#a","text":"Array long A[R][S][T] An element A[i][j][k] would have an offset = space taken by i 3d rows + space taken by j 2d rows + space taken by k long data. \\[ A_{i,j,k} = i \\cdot S \\cdot T \\cdot L + j \\cdot T \\cdot L + k \\cdot L \\] where L is the size of the data type. Here, L is 8 bytes. We get \\[ A_{i,j,k} = 8 \\cdot (i \\cdot S \\cdot T + j \\cdot T + k) \\]","title":"A."},{"location":"chapter3/3.64/#b","text":"From the assembly code, we get \\[ A[i][j][k] = A + 65 \\cdot i + 13 \\cdot j + k \\] Comparing coefficients from the earlier equation, we get \\(65 = S \\cdot T\\) and \\(13 = T\\) . Thus, \\(S = 5\\) and \\(T = 13\\) . And, the total size of the array is 3640. \\[ R \\cdot S \\cdot T \\cdot L = 3640 \\] \\[ R = 3640 \\div (5 \\cdot 13 \\cdot 8) \\] \\(R = 7\\) , \\(S = 5\\) and \\(T = 13\\) .","title":"B."},{"location":"chapter3/3.65/","text":"3.65 A %rdx B %rax C 15 The pointer that goes column-wise has to be incremented by a value that is equivalent to the size of one full row. Each element is 8 bytes long, so we get \\(120 \\div 8 = 15\\) .","title":"3.65"},{"location":"chapter3/3.65/#365","text":"","title":"3.65"},{"location":"chapter3/3.65/#a","text":"%rdx","title":"A"},{"location":"chapter3/3.65/#b","text":"%rax","title":"B"},{"location":"chapter3/3.65/#c","text":"15 The pointer that goes column-wise has to be incremented by a value that is equivalent to the size of one full row. Each element is 8 bytes long, so we get \\(120 \\div 8 = 15\\) .","title":"C"},{"location":"chapter3/3.66/","text":"3.66 Solution Annotating the assembly code, long sum_col(long n, long A[NR(n)][NC(n)], long j) n in %rdi, A in %rsi, j in %rdx 1 sum_col: 2 leaq 1(,%rdi,4), %r8 %r8 <- 4n + 1 3 leaq (%rdi,%rdi,2), %rax %rax <- 3n 4 movq %rax, %rdi %rdi <- %rax 5 testq %rax, %rax like %rax & %rax 6 jle .L4 %rax <= 0 ? 7 salq $3, %r8 %r8 *= 8 8 leaq (%rsi,%rdx,8), %rcx ptr = A + 8*j 9 movl $0, %eax %rax <- 0 10 movl $0, %edx %rdx <- 0 11 .L3: 12 addq (%rcx), %rax result += *ptr 13 addq $1, %rdx %rdx += 1 (%rdx is i) 14 addq %r8, %rcx ptr += (4n+1)*8 15 cmpq %rdi, %rdx compare i:3n 16 jne .L3 if i != 3n, loop 17 rep; ret 18 .L4: 19 movl $0, %eax result = 0 20 ret From lines 10, 13 and 15, we can see that i goes from 0 to 3n with a step of 1. From the stopping condition, we get that NR(n) must be 3n . On line 14, we can see that the pointer is being moved ahead by \\((4n+1) \\cdot 8\\) bytes on each iteration. Because 8 is the number of bytes taken by a long , we get that \\(4n+1\\) is the number of columns in the array. NR(n) = 3n NC(n) = 4n + 1","title":"3.66"},{"location":"chapter3/3.66/#366","text":"","title":"3.66"},{"location":"chapter3/3.66/#solution","text":"Annotating the assembly code, long sum_col(long n, long A[NR(n)][NC(n)], long j) n in %rdi, A in %rsi, j in %rdx 1 sum_col: 2 leaq 1(,%rdi,4), %r8 %r8 <- 4n + 1 3 leaq (%rdi,%rdi,2), %rax %rax <- 3n 4 movq %rax, %rdi %rdi <- %rax 5 testq %rax, %rax like %rax & %rax 6 jle .L4 %rax <= 0 ? 7 salq $3, %r8 %r8 *= 8 8 leaq (%rsi,%rdx,8), %rcx ptr = A + 8*j 9 movl $0, %eax %rax <- 0 10 movl $0, %edx %rdx <- 0 11 .L3: 12 addq (%rcx), %rax result += *ptr 13 addq $1, %rdx %rdx += 1 (%rdx is i) 14 addq %r8, %rcx ptr += (4n+1)*8 15 cmpq %rdi, %rdx compare i:3n 16 jne .L3 if i != 3n, loop 17 rep; ret 18 .L4: 19 movl $0, %eax result = 0 20 ret From lines 10, 13 and 15, we can see that i goes from 0 to 3n with a step of 1. From the stopping condition, we get that NR(n) must be 3n . On line 14, we can see that the pointer is being moved ahead by \\((4n+1) \\cdot 8\\) bytes on each iteration. Because 8 is the number of bytes taken by a long , we get that \\(4n+1\\) is the number of columns in the array. NR(n) = 3n NC(n) = 4n + 1","title":"Solution"},{"location":"chapter3/3.67/","text":"3.67 Solution A. B. stack pointer + 64 C. Relative to the stack pointer. But there is an extra offset of 8 added due to call (occupied by the return address), so an offset of 24 from %rsp would refer to s.p from the answer to A, and s.a[0] would be at an offset of 8. D. By moving elements of s to addresses relative to the argument. E. F. Structs can be passed as part of the \"Argument build\" area on the stack frame of the caller. The argument that is passed in %rdi register was the memory address of where the return struct should be stored. The space for it was allocated by the caller before hand. This was also the address that was returned.","title":"3.67"},{"location":"chapter3/3.67/#367","text":"","title":"3.67"},{"location":"chapter3/3.67/#solution","text":"","title":"Solution"},{"location":"chapter3/3.67/#a","text":"","title":"A."},{"location":"chapter3/3.67/#b","text":"stack pointer + 64","title":"B."},{"location":"chapter3/3.67/#c","text":"Relative to the stack pointer. But there is an extra offset of 8 added due to call (occupied by the return address), so an offset of 24 from %rsp would refer to s.p from the answer to A, and s.a[0] would be at an offset of 8.","title":"C."},{"location":"chapter3/3.67/#d","text":"By moving elements of s to addresses relative to the argument.","title":"D."},{"location":"chapter3/3.67/#e","text":"","title":"E."},{"location":"chapter3/3.67/#f","text":"Structs can be passed as part of the \"Argument build\" area on the stack frame of the caller. The argument that is passed in %rdi register was the memory address of where the return struct should be stored. The space for it was allocated by the caller before hand. This was also the address that was returned.","title":"F."},{"location":"chapter3/3.68/","text":"3.68 Solution Annotating the assembly code: void setVal(str1 *p, str2 *q) p in %rdi, q in %rsi 1 setVal: 2 movslq 8(%rsi), %rax # %rax = (long) q.t 3 addq 32(%rsi), %rax # %rax += q.u 4 movq %rax, 184(%rdi) # p.y = %rax 5 ret From the assembly code and C code, we can make the observations that: q.t is at an offset of 8 from start of q. \\(\\implies\\) length of str2.array ( \\(B\\) ) is between 5 and 8 inclusive due to the padding for t . \\(\\implies\\) At offset 12, q.t ends and q.s starts q.u is at an offset of 32 from the start of q. \\(\\implies\\) q.s stretched from offset 12 to between 25 and 32 inclusive, for the padding to match. p.y is at an offset of 184 from the start of p . \\(\\implies\\) Array x occupied somewhere between 177 and 184 bytes. Putting all 3 inequalities in mathematical form, we get: \\[ 5 <= B <= 8, 13 <= 2 \\cdot A <= 20,\\ 177 <= 4 \\cdot A \\cdot B <= 184 \\] \\[ 7 <= A <= 10\\ \\text{, dividing 2nd inequality by 2} \\] Divding 3rd inequality by 4: \\[ 45 <= A \\cdot B <= 46 \\] Two cases: Case 1: \\(A \\cdot B = 45\\) Valid values for (A, B): (9, 5) Case 2: \\(A \\cdot B = 46\\) No valid values possible in this case because \\(46 = 23 \\cdot 2\\) and 23 is a prime. We can conclude that A = 9 and B = 5 .","title":"3.68"},{"location":"chapter3/3.68/#368","text":"","title":"3.68"},{"location":"chapter3/3.68/#solution","text":"Annotating the assembly code: void setVal(str1 *p, str2 *q) p in %rdi, q in %rsi 1 setVal: 2 movslq 8(%rsi), %rax # %rax = (long) q.t 3 addq 32(%rsi), %rax # %rax += q.u 4 movq %rax, 184(%rdi) # p.y = %rax 5 ret From the assembly code and C code, we can make the observations that: q.t is at an offset of 8 from start of q. \\(\\implies\\) length of str2.array ( \\(B\\) ) is between 5 and 8 inclusive due to the padding for t . \\(\\implies\\) At offset 12, q.t ends and q.s starts q.u is at an offset of 32 from the start of q. \\(\\implies\\) q.s stretched from offset 12 to between 25 and 32 inclusive, for the padding to match. p.y is at an offset of 184 from the start of p . \\(\\implies\\) Array x occupied somewhere between 177 and 184 bytes. Putting all 3 inequalities in mathematical form, we get: \\[ 5 <= B <= 8, 13 <= 2 \\cdot A <= 20,\\ 177 <= 4 \\cdot A \\cdot B <= 184 \\] \\[ 7 <= A <= 10\\ \\text{, dividing 2nd inequality by 2} \\] Divding 3rd inequality by 4: \\[ 45 <= A \\cdot B <= 46 \\] Two cases: Case 1: \\(A \\cdot B = 45\\) Valid values for (A, B): (9, 5) Case 2: \\(A \\cdot B = 46\\) No valid values possible in this case because \\(46 = 23 \\cdot 2\\) and 23 is a prime. We can conclude that A = 9 and B = 5 .","title":"Solution"},{"location":"chapter3/3.69/","text":"3.69 Solution Let's annotate the assembly code void test(long i, b_struct *bp) i in %rdi, bp in %rsi 0000000000000000 <test>: 0: 8b 8e 20 01 00 00 mov 0x120(%rsi),%ecx # fetch bp->last 6: 030e add (%rsi),%ecx # bp->last + bp->first 8: 48 8d 04 bf lea (%rdi,%rdi,4),%rax # 5i c: 48 8d 04 c6 lea (%rsi,%rax,8),%rax # %rax <- bp + 40i 10: 48 8b 50 08 mov 0x8(%rax),%rdx # %rdx <- M[bp + 40i + 8] 14: 48 63 c9 movslq %ecx,%rcx # sign-extend %ecx 17: 48 89 4c d0 10 mov %rcx,0x10(%rax,%rdx,8) # M[bp + 40i + 16 + %rdx*8] <- %rcx 1c: c3 retq bp->last has an offset of 288 \\(\\implies\\) sizeof(int) + padding + sizeof(a_struct) * CNT is 288. ap = bp + 8 + 40i %rdx stores ap->idx A. In b_struct , first comes before the array a[CNT] , and as we can see from the way ap is gotten, there is an extra offset of 8 apart from the offset caused by preceding elements in a . These 8 bits include int first , and a padding of 4 bytes after that. From the first point, we see 4 + 4 + 40 * CNT = 288 \\(\\implies\\) CNT = 7 . B. In the final mov instruction, bp + 40i + 16 + %rdx * 8 can be written as ap + 8 + idx * 8 . We can conclude from this that in a_struct , the first 8 bits are occupied by idx , and the later bits are occupied by an array with elements of size 8 , i.e. of type long . Because the size of a_struct is 40 (from its array in b_struct ), \\(8 + 8 * len(x) = 40\\) . We obtain that length of array x is 4. typedef struct { long idx; long x[4]; };","title":"3.69"},{"location":"chapter3/3.69/#369","text":"","title":"3.69"},{"location":"chapter3/3.69/#solution","text":"Let's annotate the assembly code void test(long i, b_struct *bp) i in %rdi, bp in %rsi 0000000000000000 <test>: 0: 8b 8e 20 01 00 00 mov 0x120(%rsi),%ecx # fetch bp->last 6: 030e add (%rsi),%ecx # bp->last + bp->first 8: 48 8d 04 bf lea (%rdi,%rdi,4),%rax # 5i c: 48 8d 04 c6 lea (%rsi,%rax,8),%rax # %rax <- bp + 40i 10: 48 8b 50 08 mov 0x8(%rax),%rdx # %rdx <- M[bp + 40i + 8] 14: 48 63 c9 movslq %ecx,%rcx # sign-extend %ecx 17: 48 89 4c d0 10 mov %rcx,0x10(%rax,%rdx,8) # M[bp + 40i + 16 + %rdx*8] <- %rcx 1c: c3 retq bp->last has an offset of 288 \\(\\implies\\) sizeof(int) + padding + sizeof(a_struct) * CNT is 288. ap = bp + 8 + 40i %rdx stores ap->idx","title":"Solution"},{"location":"chapter3/3.69/#a","text":"In b_struct , first comes before the array a[CNT] , and as we can see from the way ap is gotten, there is an extra offset of 8 apart from the offset caused by preceding elements in a . These 8 bits include int first , and a padding of 4 bytes after that. From the first point, we see 4 + 4 + 40 * CNT = 288 \\(\\implies\\) CNT = 7 .","title":"A."},{"location":"chapter3/3.69/#b","text":"In the final mov instruction, bp + 40i + 16 + %rdx * 8 can be written as ap + 8 + idx * 8 . We can conclude from this that in a_struct , the first 8 bits are occupied by idx , and the later bits are occupied by an array with elements of size 8 , i.e. of type long . Because the size of a_struct is 40 (from its array in b_struct ), \\(8 + 8 * len(x) = 40\\) . We obtain that length of array x is 4. typedef struct { long idx; long x[4]; };","title":"B."},{"location":"chapter3/3.70/","text":"3.70 A. e1.p 0 e1.y 8 e2.x 0 e2.next 8 B. 16 bytes C. void proc (union ele *up) up in %rdi 1 proc: 2 movq 8(%rdi), %rax # %rax = up->next 3 movq (%rax), %rdx # %rdx = up->next->p 4 movq (%rdx), %rdx # %rdx = *(up->next->p) 5 subq 8(%rax), %rdx # %rdx = *(up->next->p) - up->next->y 6 movq %rdx, (%rdi) # up->x = *(up->next->p) - up->next->y 7 ret Filling in the C code: void proc (union ele *up) { up->x = *(up->next->p) - up->next->y; }","title":"3.70"},{"location":"chapter3/3.70/#370","text":"","title":"3.70"},{"location":"chapter3/3.70/#a","text":"e1.p 0 e1.y 8 e2.x 0 e2.next 8","title":"A."},{"location":"chapter3/3.70/#b","text":"16 bytes","title":"B."},{"location":"chapter3/3.70/#c","text":"void proc (union ele *up) up in %rdi 1 proc: 2 movq 8(%rdi), %rax # %rax = up->next 3 movq (%rax), %rdx # %rdx = up->next->p 4 movq (%rdx), %rdx # %rdx = *(up->next->p) 5 subq 8(%rax), %rdx # %rdx = *(up->next->p) - up->next->y 6 movq %rdx, (%rdi) # up->x = *(up->next->p) - up->next->y 7 ret Filling in the C code: void proc (union ele *up) { up->x = *(up->next->p) - up->next->y; }","title":"C."},{"location":"chapter3/3.71/","text":"3.71 Solution Handles the following cases: - When line is longer than buffer - Line is being read from a file that doesn't end with a newline (stops at EOF) Doesn't handle: - When some characters follow a null byte in the input. When a null-byte is encountered it is treated like end of string. #include <stdio.h> #define BUF_SIZE 10 char getLast(char *word) { char last = '\\0'; while (*word != '\\0') { last = *word; word++; } return last; } void good_echo() { char buf[BUF_SIZE]; while (fgets(buf, sizeof(buf), stdin) != NULL) { fputs(buf, stdout); if (buf[0] != '\\0' && buf[BUF_SIZE-1] == '\\0' && getLast(buf) == '\\n') break; } } int main() { good_echo(); }","title":"3.71"},{"location":"chapter3/3.71/#371","text":"","title":"3.71"},{"location":"chapter3/3.71/#solution","text":"Handles the following cases: - When line is longer than buffer - Line is being read from a file that doesn't end with a newline (stops at EOF) Doesn't handle: - When some characters follow a null byte in the input. When a null-byte is encountered it is treated like end of string. #include <stdio.h> #define BUF_SIZE 10 char getLast(char *word) { char last = '\\0'; while (*word != '\\0') { last = *word; word++; } return last; } void good_echo() { char buf[BUF_SIZE]; while (fgets(buf, sizeof(buf), stdin) != NULL) { fputs(buf, stdout); if (buf[0] != '\\0' && buf[BUF_SIZE-1] == '\\0' && getLast(buf) == '\\n') break; } } int main() { good_echo(); }","title":"Solution"},{"location":"chapter3/3.72/","text":"3.72 Solution Assembly code: long aframe(long n, long idx, long *q) n in %rdi, idx in %rsi, q in %rdx 1 aframe: 2 pushq %rbp 3 movq %rsp, %rbp 4 subq $16, %rsp Allocate space for i (%rsp = s1) 5 leaq 30(,%rdi,8), %rax 6 andq $-16, %rax 7 subq %rax, %rsp Allocate space for array p (%rsp = s2) 8 leaq 15(%rsp), %r8 9 andq $-16, %r8 Set %r8 to &p[0] \u22ee A. \\[ s2 = s1 - (30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) \\] The \\(k\\ \\text{AND}\\ (-16)\\) is equivalent to \\(k - k \\bmod 16\\) (from the bitwise representation of -16) We have, \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - (30 + 8 \\cdot n) \\bmod 16\\) \\(= 30 + 8 \\cdot n - (16 + 8 \\cdot n + 8 + 6) \\bmod 16\\) \\(= 30 + 8 \\cdot n - (16 + 8 \\cdot (n+1) + 6) \\bmod 16\\) We have two cases, when n is even and when is odd When n is even, \\(n = 2k\\) \\(\\implies (16 + 8 \\cdot (n + 1) + 6) \\bmod 16 = (16 + 8 \\cdot (2k + 1) + 6) \\bmod 16\\) \\(= (16 \\cdot (k + 1) + 14) \\bmod 16\\) \\(= 14\\) \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - 14 = 16 + 8 \\cdot n\\) When n is odd, n + 1 is even. \\(\\implies n + 1 = 2k\\) \\((16 + 8 \\cdot (n + 1) + 6) \\bmod 16 = (16 + 8 \\cdot (2k) + 6) \\bmod 16\\) \\(= 6\\) We get, \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - 6 = 24 + 8 \\cdot n\\) \\[ \\begin{align} s_2 = \\begin{cases} s_1 - 8 \\cdot n - 16 & \\text{if n is even} \\\\ s_1 - 8 \\cdot n - 24 & \\text{if n is odd} \\end{cases} \\end{align} \\] B. From lines 8 and 9, \\(p = 15 + s_2\\ \\text{AND}\\ (-16)\\) . \\(= 15 + s_2 - (15 + s_2) \\bmod 16\\) \\((15 + s_2) \\bmod 16 = (15 \\bmod 16 + s_2 \\bmod 16) \\bmod 16\\) \\(= (15 + s_2 \\bmod 16) \\bmod 16\\) \\(s_2 \\bmod 16\\) can have 16 values, from 0 to 15. We have these two cases: Case 1: \\(s_2 \\bmod 16 = 0\\) \\((15 + s_2 \\bmod 16) \\bmod 16 = 15\\) , and we get \\(p = 15 + s_2 - 15 = s_2\\) Case 2: \\(1 <= (s_2 \\bmod 16) <= 15\\) Let \\(k = s_2 \\bmod 16\\) \\((15 + k) \\bmod 16 = (16 - 1 + k) \\bmod 16 = (k - 1) \\bmod 16\\) \\(0 <= k - 1 <= 14 \\implies p = 15 + s_2 - (s_2 \\bmod 16 - 1) = 16 + s_2 - s_2 \\bmod 16\\) \\[ \\begin{align} p = \\begin{cases} s_2 & \\text{if $s_2$ is a multiple of 16} \\\\ s_2 + 16 - s_2 \\bmod 16 & \\text{otherwise} \\end{cases} \\end{align} \\] C. \\(e_1 + e_2 = s_1 - s_2\\) From A, \\(e_1 + e_2\\) is either 16 (when \\(n\\) is even) or 24 (when \\(n\\) is odd). From B, \\(e2\\) is either 0 (when \\(s_2\\) , and consequently \\(s_1\\) , as the offset between \\(s_1\\) and \\(s_2\\) is also a multiple of 16), or \\(16 - s_2 mod 16\\) (same as \\(16 - s_1 mod 16\\) ). We end up with four cases \\[ \\begin{align} e_1 = \\begin{cases} 24 - 0 & \\text{if $s_1$ is a multiple of 16 and n is odd} \\\\ 24 - (16 - s_1 \\bmod 16) & \\text{if $s_1$ is not a multiple of 16 and n is odd} \\\\ 16 - 0 & \\text{if $s_1$ is a multiple of 16 and n is even} \\\\ 16 - (16 - s_1 \\bmod 16) & \\text{if $s_1$ is not a mulitiple of 16 and n is even} \\end{cases} \\end{align} \\] By comparing these cases, the case for maximum is case 1 where \\(e_1\\) is 24, and the case for minimum is the last one, where \\(e_1\\) is 1 when \\(s_1 \\bmod 16\\) is 1. D. Always a multiple of 16 relative to \\(s_1\\) .","title":"3.72"},{"location":"chapter3/3.72/#372","text":"","title":"3.72"},{"location":"chapter3/3.72/#solution","text":"Assembly code: long aframe(long n, long idx, long *q) n in %rdi, idx in %rsi, q in %rdx 1 aframe: 2 pushq %rbp 3 movq %rsp, %rbp 4 subq $16, %rsp Allocate space for i (%rsp = s1) 5 leaq 30(,%rdi,8), %rax 6 andq $-16, %rax 7 subq %rax, %rsp Allocate space for array p (%rsp = s2) 8 leaq 15(%rsp), %r8 9 andq $-16, %r8 Set %r8 to &p[0] \u22ee","title":"Solution"},{"location":"chapter3/3.72/#a","text":"\\[ s2 = s1 - (30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) \\] The \\(k\\ \\text{AND}\\ (-16)\\) is equivalent to \\(k - k \\bmod 16\\) (from the bitwise representation of -16) We have, \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - (30 + 8 \\cdot n) \\bmod 16\\) \\(= 30 + 8 \\cdot n - (16 + 8 \\cdot n + 8 + 6) \\bmod 16\\) \\(= 30 + 8 \\cdot n - (16 + 8 \\cdot (n+1) + 6) \\bmod 16\\) We have two cases, when n is even and when is odd When n is even, \\(n = 2k\\) \\(\\implies (16 + 8 \\cdot (n + 1) + 6) \\bmod 16 = (16 + 8 \\cdot (2k + 1) + 6) \\bmod 16\\) \\(= (16 \\cdot (k + 1) + 14) \\bmod 16\\) \\(= 14\\) \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - 14 = 16 + 8 \\cdot n\\) When n is odd, n + 1 is even. \\(\\implies n + 1 = 2k\\) \\((16 + 8 \\cdot (n + 1) + 6) \\bmod 16 = (16 + 8 \\cdot (2k) + 6) \\bmod 16\\) \\(= 6\\) We get, \\((30 + 8 \\cdot n)\\ \\text{AND}\\ (-16) = 30 + 8 \\cdot n - 6 = 24 + 8 \\cdot n\\) \\[ \\begin{align} s_2 = \\begin{cases} s_1 - 8 \\cdot n - 16 & \\text{if n is even} \\\\ s_1 - 8 \\cdot n - 24 & \\text{if n is odd} \\end{cases} \\end{align} \\]","title":"A."},{"location":"chapter3/3.72/#b","text":"From lines 8 and 9, \\(p = 15 + s_2\\ \\text{AND}\\ (-16)\\) . \\(= 15 + s_2 - (15 + s_2) \\bmod 16\\) \\((15 + s_2) \\bmod 16 = (15 \\bmod 16 + s_2 \\bmod 16) \\bmod 16\\) \\(= (15 + s_2 \\bmod 16) \\bmod 16\\) \\(s_2 \\bmod 16\\) can have 16 values, from 0 to 15. We have these two cases: Case 1: \\(s_2 \\bmod 16 = 0\\) \\((15 + s_2 \\bmod 16) \\bmod 16 = 15\\) , and we get \\(p = 15 + s_2 - 15 = s_2\\) Case 2: \\(1 <= (s_2 \\bmod 16) <= 15\\) Let \\(k = s_2 \\bmod 16\\) \\((15 + k) \\bmod 16 = (16 - 1 + k) \\bmod 16 = (k - 1) \\bmod 16\\) \\(0 <= k - 1 <= 14 \\implies p = 15 + s_2 - (s_2 \\bmod 16 - 1) = 16 + s_2 - s_2 \\bmod 16\\) \\[ \\begin{align} p = \\begin{cases} s_2 & \\text{if $s_2$ is a multiple of 16} \\\\ s_2 + 16 - s_2 \\bmod 16 & \\text{otherwise} \\end{cases} \\end{align} \\]","title":"B."},{"location":"chapter3/3.72/#c","text":"\\(e_1 + e_2 = s_1 - s_2\\) From A, \\(e_1 + e_2\\) is either 16 (when \\(n\\) is even) or 24 (when \\(n\\) is odd). From B, \\(e2\\) is either 0 (when \\(s_2\\) , and consequently \\(s_1\\) , as the offset between \\(s_1\\) and \\(s_2\\) is also a multiple of 16), or \\(16 - s_2 mod 16\\) (same as \\(16 - s_1 mod 16\\) ). We end up with four cases \\[ \\begin{align} e_1 = \\begin{cases} 24 - 0 & \\text{if $s_1$ is a multiple of 16 and n is odd} \\\\ 24 - (16 - s_1 \\bmod 16) & \\text{if $s_1$ is not a multiple of 16 and n is odd} \\\\ 16 - 0 & \\text{if $s_1$ is a multiple of 16 and n is even} \\\\ 16 - (16 - s_1 \\bmod 16) & \\text{if $s_1$ is not a mulitiple of 16 and n is even} \\end{cases} \\end{align} \\] By comparing these cases, the case for maximum is case 1 where \\(e_1\\) is 24, and the case for minimum is the last one, where \\(e_1\\) is 1 when \\(s_1 \\bmod 16\\) is 1.","title":"C."},{"location":"chapter3/3.72/#d","text":"Always a multiple of 16 relative to \\(s_1\\) .","title":"D."},{"location":"chapter3/3.73/","text":"3.73 Solution This is the solution, with inline asm code in C: range_t find_range(float x) { __asm__( \"vxorps %xmm1, %xmm1, %xmm1\\n\" \"vucomiss %xmm1, %xmm0\\n\" \"jp .L1\\n\" \"ja .L2\\n\" \"jb .L3\\n\" \"movl $1, %eax\\n\" \"jmp .done\\n\" \".L1:\\n\" \"movl $3, %eax\\n\" \"jmp .done\\n\" \".L2:\\n\" \"movl $2, %eax\\n\" \"jmp .done\\n\" \".L3:\\n\" \"movl $0, %eax\\n\" \".done:\\n\" ); } The complete C file, along with checks over all \\(2^{32}\\) values can be found here .","title":"3.73"},{"location":"chapter3/3.73/#373","text":"","title":"3.73"},{"location":"chapter3/3.73/#solution","text":"This is the solution, with inline asm code in C: range_t find_range(float x) { __asm__( \"vxorps %xmm1, %xmm1, %xmm1\\n\" \"vucomiss %xmm1, %xmm0\\n\" \"jp .L1\\n\" \"ja .L2\\n\" \"jb .L3\\n\" \"movl $1, %eax\\n\" \"jmp .done\\n\" \".L1:\\n\" \"movl $3, %eax\\n\" \"jmp .done\\n\" \".L2:\\n\" \"movl $2, %eax\\n\" \"jmp .done\\n\" \".L3:\\n\" \"movl $0, %eax\\n\" \".done:\\n\" ); } The complete C file, along with checks over all \\(2^{32}\\) values can be found here .","title":"Solution"},{"location":"chapter3/3.74/","text":"3.74 Solution This is the solution, with inline asm code in C: range_t find_range(float x) { __asm__( \"vxorps %xmm1, %xmm1, %xmm1\\n\" \"vucomiss %xmm1, %xmm0\\n\" \"movl $3, %edx\\n\" \"movl $2, %ecx\\n\" \"movl $1, %edi\\n\" \"movl $0, %esi\\n\" \"cmova %ecx, %eax\\n\" \"cmove %edi, %eax\\n\" \"cmovb %esi, %eax\\n\" \"cmovp %edx, %eax\\n\" ); } The complete C file, along with checks over all \\(2^{32}\\) values can be found here .","title":"3.74"},{"location":"chapter3/3.74/#374","text":"","title":"3.74"},{"location":"chapter3/3.74/#solution","text":"This is the solution, with inline asm code in C: range_t find_range(float x) { __asm__( \"vxorps %xmm1, %xmm1, %xmm1\\n\" \"vucomiss %xmm1, %xmm0\\n\" \"movl $3, %edx\\n\" \"movl $2, %ecx\\n\" \"movl $1, %edi\\n\" \"movl $0, %esi\\n\" \"cmova %ecx, %eax\\n\" \"cmove %edi, %eax\\n\" \"cmovb %esi, %eax\\n\" \"cmovp %edx, %eax\\n\" ); } The complete C file, along with checks over all \\(2^{32}\\) values can be found here .","title":"Solution"},{"location":"chapter3/3.75/","text":"3.75 Solution A. Real part takes up one FP register, imaginary part takes the next. Consecutive registers are used (extrapolating this, if stored on the stack as arguments, they should be stored consecutively in a similar fashion). B. Real part of return value is stored in %xmm0 , imaginary part in %xmm1 .","title":"3.75"},{"location":"chapter3/3.75/#375","text":"","title":"3.75"},{"location":"chapter3/3.75/#solution","text":"","title":"Solution"},{"location":"chapter3/3.75/#a","text":"Real part takes up one FP register, imaginary part takes the next. Consecutive registers are used (extrapolating this, if stored on the stack as arguments, they should be stored consecutively in a similar fashion).","title":"A."},{"location":"chapter3/3.75/#b","text":"Real part of return value is stored in %xmm0 , imaginary part in %xmm1 .","title":"B."}]}